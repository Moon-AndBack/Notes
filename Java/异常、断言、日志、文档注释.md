# 异常

**世界上没有不存在bug的程序，没有bug的程序是莫得灵魂的程序，莫得bug就莫得感情。**

## Java中的异常

在Java中，万事万物皆对象，对程序产生的bug也不例外。Throwable是所有异常的顶层父类。Throwable在下层立即分解为两个分支：Error和Excption。

Error中大多数错误都是与系统有关，而与程序员无关。对于程序产生Error错误程序员大可不必以为是程序本身的问题，更多的是JVM虚拟机与操作系统的问题。

Excption是程序本身可以处理的异常，Excption分为运行时异常（RuntimeException）和非运行时异常（其他异常），运行时异常只发生在程序运行期间，如果发生运行时异常一定是你的问题。而非运行时异常是可以被程序员捕获并且处理的异常。

Java语言规范将派生于Error类或者派生于RuntimeException类的异常称为非检查型异常，所有其他异常称为检查型异常。你应当捕获所有检查型异常来确保程序可以通过编译。

## 异常的处理方式

处理一场主要有两种：捕获异常和抛出异常。

通常情况下在某些场景应当杜绝使用捕获异常，例如在编写的复用类中应当抛出异常而不是捕获异常，因为复用类中的方法可能会被多个不同的程序调用，应当把异常抛出给被调用者捕获被调用者可以根据适当的场景来选择合适的处理机制。

try块可以拥有一个或多个catch块也可以没有catch块，当try块后没有catch块必须由方法签名中抛出错误，try块后可以有一个finally块或没有finally块不能有多个finally块，finally前必须有try块。

```java
// 抛出异常和捕获异常的示例

public class MyProgram{
    public static void main(String[] args) {
        // 创建自定类的实例
        ArrayClass arrayClass = new ArrayClass({"Hellow", "Word", "!"}, {12, 13, 5});
        // 使用try关键字来包裹可能会出现错误的代码
        try {
            // 这里会发生数组访问越界异常
            int i = arrayClass.getANumber(4);
        }
        /* catch关键字指定了要捕获的异常并给异常设置一个变量名
        	catch可以连续使用以捕获多个异常通常这些异常都在方法声明中创建了
        */
        catch(ArrayIndexOutOfBoundsException e) {
            // 对异常的操作
            e.printStackTrace();
        }
        // 在捕获异常后会执行完finally块内的代码后再退出
        finally {
            // 要执行的最终操作
            System.exit(0);
        }
    }
}

class ArrayClass{
    private String[] str;
    private int[] array;
    
    public ArrayClass(String[] str, int[] array) {
        this.str = str;
        this.array = array;
    }
    
    // 创建一个数组下标越界异常并在发生时抛出，可以声明多个异常只使用逗号隔开
    public int getArrayANumber(int index) throws ArrayIndexOutOfBoundsException {
        return array[index];
    }
    
    public int getAString(int index) throws ArrayIndexOutOfBoundsException {
        return str[index];
    }
}

// 你可以在程序中创建一个异常并抛出
try {
    ...
        // 创建并抛出一个异常
    throw new Exception();
}catch(Exception e) {
    ...
}
```

### 创建一个自己的异常类

```java
// 自定义异常需要继承Exception类或者其子类
class MyException extends Excption {
    // 一个空参构造器
    public MyExcption() {}
    // 一个有参构造器并将程序指定的错误信息交给父类
    public MyExcption(String msg) {super(msg); }
}

class Runnn{
    public static void main(String[] args) {
        try{
            // 创建一个异常并传入指定的错误信息
            throw new MyExcption("自定义异常");
        }catch(Myexcption e) {
            // 这会将指定的错误信息打印到标准错误流
            e.printStackTrace();
        }
    }
}
```

### 在catch语句中抛出异常

```java
// 创建一个异常
try{
    throw new MyException("老异常");
}
// 捕获这个异常
catch(MyException e) {
    // 再次创建一个异常
    MyException a = new MyException("新异常");
    // 将之前的异常进行包装使其携带新创建的异常信息
    a.initCause(e);
    // 将错误打印到标准错误流
    e.printStackTrace();
}

/* Out:MyException:新异常
		...
       MyException:老异常
        ...
*/
```

### try-with-resources语句

在Java7之前，如果要打开多个文件需要为每个不同的流分别设置try...catch语句，但是在Java7之后简化了这种行为。如果一个资源类实现了AutoCloseable接口，在声明阶段将声明语句放到try的条件括号中，当代码退出当前try作用域是，流资源将会被自动关闭而无需调用close方法，在Java9中你还可以在try之前声明流变量并在try条件括号中包裹以实现自动关闭流资源的目的。

```java
// Java7
try (
	FileInputStream f1 = new FileInputStream("...");
    FileOutputStream f2 = new FileOutputStream("...")){
    ...
}

// Java9
PrintWrite p1 = null;
try(p1) {
    p1 = new PrintWrite(System.out);
}
```

*AutoCloseable只有一个方法`clase() return void`为了自动关闭资源而创建的一个类*

# 断言

断言仅适合在程序开发测试时使用，并且JVM默认禁用断言，断言的判定失败会导致程序不可恢复错误。

```java
// 断言有两种使用方式

int a = 10;

// 第一种方法将会使程序停止运行并没有任何消息
assert a > 20;
// 这种方法将会把 ：后面的字符串打印在标准错误流
assert a > 20 : "a并没有大于20";
```

## 断言的开启

启用和禁用断言是类加载器的功能，在禁用断言时在加载类的时候会自动忽略断言代码，IDEA中会自动识别断言。

# 日志

# 文档注释





