# JVM虚拟机

Java语言诞生的一个重要理念就是跨平台。得益于JVM，Java程序可以运行于任何安装了Jre环境的机器上。我们通长只需要在一个平台编写Java程序就可以使其运行在今天大多数的系统上。今天最常见的Java跨平台操作当属于服务端开发，通过在Windows或者Mac OS编写Java Web程序，通过测试后上传到服务端（一般是Linux系统）运行。20年的发展历程使得Java常年占据语言排行榜前三的地位，如今的Java可以说无可替代。但是谁也无法预料下一个10年，下下个10年Java是否还能如此强胜。

要想深入理解Java那么JVM是绕不过去的坎。

## Java程序内存区域

JVM在执行Java程序的时候会把它所管理的内存划分为若干个不同的数据区域，每个区域有其特定的用途以及创建和销毁的时间。有的区域随JVM的启动而存在，有的区域则是根据用户编写程序的线程启动或结束而创建和销毁。根据《Java虚拟机规范》规定，JVM所管理的内存区域包括如下：

- 程序计数器：占据一块较小的空间，可以看作线程字节码的行号指示器，字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令。每条线程都有自己独立的程序计数器，各线程之间互不影响，独立存在，称为“线程私有”内存。《Java虚拟机规范》没有规定任何OutIOfMemoryError情况。
- 虚拟机栈：通常我们所说的栈内存就是Java虚拟机栈。在每个方法被调用的时候，虚拟机会同步创建一个**栈帧**，存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从被调用直至结束就代表着一个栈桢在虚拟机栈中从入栈到出栈的过程。《Java虚拟机规范》中对线程请求深度大于虚拟机深度将抛出StackOverflowError异常，如果虚拟机支持栈容量动态扩展，但无法申请到足够分空间时会抛出OutOfMemoryError异常。
  - 局部变量表存储了编译期可知的各种Java基本数据类型，对象引用和returnAddress类型。这些数据类型在局部变量表中存储空间以局部变量槽（Slot）表示，64位的long和double会占据两个变量槽，其余类型只占据一个变量槽。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，需要占用的局部变量空间是完全确定的，运行期间不会更改局部变量表的大小。
- 本地方法栈：是供JVM使用到的本地方法服务的，《Java虚拟机规范》没有对本地方法栈做任何强制规定，不同虚拟机可以自由实现。其异常和虚拟机栈相同。
- 堆：堆是JVM所管理的最大一块区域，被所有线程共享并在虚拟机启动时创建，几乎所有的对象实例都是在堆上分配的（随着虚拟机发展对象不一定只在堆上），但是堆上存储的只能是对象实例，Java的GC工作在此区域。当堆中没有内存完成对象实例的分配时，并且堆也无法扩展，会抛出OutOfMemoryError异常。
- 方法区：方法区被各个线程共享，用来存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。当方法区无法满足新的内存分配时，会抛出OutOfMemoryError异常。
- 运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有以一项是常量池表，用于存放编译器生成的各种字面量，符号引用，这部分内容将在类加载后直接存放到方法区运行时常量池。
- 直接内存：JDK4中新引入了一个NIO类，可以直接在堆外分配内存，然后通过一个存储在堆中的DirectByteBuffer对象来为这块内存引用进行操作。其受到硬件内存限制可能因为动态扩展时抛出OutOfMemoryError异常。

## Java普通对象的创建

Java是一门完全面向对象语言，在程序的运行过程中有若干个对象被创建。通常我们使用new操作符来创建一个对象，当JVM虚拟机遇到一段字节码new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个类是否已经被加载、解析和初始化，如果没有，那必须先执行相应的类加载过程。

在类加载检查通过以后接下来虚拟机将为新生对象分配内存，对象所需的内存空间在类加载完成时便可完全确定，为类的实例分配空间有两种方式，当堆内存的空间是完整且连续的，可用内存和已用内存中间使用一个指针划分。会直接把类所需的空闲内存划分到已用内存中，这种方式被称为“指针碰撞”。如果堆内存并不是完全规整的，会使用”空闲列表“的分配方式，虚拟机维护着一个列表，列表标记了那块内存是已经使用的那块内存是未使用的，在分配对象实例的时候会寻找足够大小的空闲内存分分配并在列表上更新记录。